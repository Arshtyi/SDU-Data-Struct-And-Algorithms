根据搜索树的定义，在继承链表描述二叉树的基础上继承得到二叉搜索树的模板类，并新增两个函数：按搜索树规则插入结点，排序输出，前者基于与左右孩子数据比较大小实现，后者只需简单中序遍历搜索即可：

```c++
template <class T>
struct binaryTreeNode
{
    T element;
    binaryTreeNode<T> *leftChild, *rightChild;
    binaryTreeNode() : leftChild(NULL), rightChild(NULL) {}
    binaryTreeNode(const T &theElement) : element(theElement), leftChild(NULL), rightChild(NULL) {}
    binaryTreeNode(const T &theElement, binaryTreeNode<T> *theLeftChild, binaryTreeNode<T> *theRightNode) : element(theElement), leftChild(theLeftChild), rightChild(theRightNode) {}
};

template <class T>
class linkedBinaryTree
{
protected:
    binaryTreeNode<T> *root;
    int treeSize;

public:
    linkedBinaryTree() : root(NULL), treeSize(0) {}
    bool empty() const { return treeSize == 0; }
    int size() const { return treeSize; }
    void preOrder(binaryTreeNode<T> *t);
    void inOrder(binaryTreeNode<T> *t);
    void inOrder() { inOrder(root); }
    void postOrder(binaryTreeNode<T> *t);
};

template <class T>
class binarySearchTree : public linkedBinaryTree<T>
{
public:
    void insert(const T &theElement);
    void sort_output() { this->inOrder(); }
};
```

其中，`binarySearchTree`的`insert`函数如下所示：

```c++
template <class T>
void binarySearchTree<T>::insert(const T &theElement)
{
    binaryTreeNode<T> *p = this->root,*pp = NULL;
    while (p != NULL)
    {
        pp = p;
        if (theElement < p->element)
            p = p->leftChild;
        else if (theElement > p->element)
            p = p->rightChild;
        else
            return;
    }
    binaryTreeNode<T> *newNode = new binaryTreeNode<T>(theElement);
    if (this->root != NULL)
        if (theElement < pp->element)
            pp->leftChild = newNode;
        else
            pp->rightChild = newNode;
    else
        this->root = newNode;
    this->treeSize++;
}
```

利用下主函数，我们可以测试该代码正确性：

```c++
int main()
{
    binarySearchTree<int> search_tree;
    int n;
    cin >> n;
    for (int i = 0; i < n; ++i)
    {
        int num;
        cin >> num;
        search_tree.insert(num);
    }
    search_tree.sort_output();
    cout << endl;
    return 0;
}
```

测试表明可以正常输出排序结果。

下面分析该搜索树排序方法的时间复杂度：

-   最坏情况：树退化为链表

    插入一个元素需要沿着树的深度向下遍历，每次只访问一个子树。当树退化为链表时，树的高度为$O(n)$，因此插入一个元素的复杂度为$O(n)$
    如果有$n$个元素依次插入，最坏情况下总时间复杂度为$O(n^2)$

-   平均情况：树保持平衡

    对于一棵随机构造的二叉搜索树，树的平均高度为$O(\log n)$，因此单次插入复杂度为$O(\log n)$。插入$n$个元素的总复杂度为$O(n \log n)$

当然，中序遍历的复杂度为$O(n)$，小于插入过程，在渐进标记下可以不计。

那么，该算法的复杂度为：

-   最坏情况: 如果树退化为链表，整体复杂度为：$O(n^2)$

-   平均情况: 树保持平衡时，整体复杂度为：$O(n \log n)$

插入排序和堆排序的复杂度为：

插入排序：

-   最坏情况: $O(n^2)$

-   平均情况：$O(n^2)$

堆排序：

-   最坏情况: $O(n \log n)$

-   平均情况：$O(n \log n)$

可以发现，搜索树排序的平均复杂度与堆排是近似的，并且是强于插入排序的，但是在最坏情况下，该排序的时间复杂度是远大于堆排的，这正是因为搜索树有可能会退化为链表，这一问题可以通过建立平衡搜索树（比如 AVL 树）解决。
